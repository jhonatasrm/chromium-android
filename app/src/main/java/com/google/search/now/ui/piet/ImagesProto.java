// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: src/main/proto/search/now/ui/piet/images.proto

package com.google.search.now.ui.piet;

public final class ImagesProto {
  private ImagesProto() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public interface ImageOrBuilder extends 
      // @@protoc_insertion_point(interface_extends:search.now.ui.piet.Image)
       com.google.protobuf.GeneratedMessageLite.
            ExtendableMessageOrBuilder<
                Image, Image.Builder> {

    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
     */
    java.util.List<com.google.search.now.ui.piet.ImagesProto.ImageSource> 
        getSourcesList();
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
     */
    com.google.search.now.ui.piet.ImagesProto.ImageSource getSources(int index);
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
     */
    int getSourcesCount();

    /**
     * <pre>
     * How the image should be scaled.
     * DEPRECATED: use the scale_type on Style message instead
     * </pre>
     *
     * <code>optional .search.now.ui.piet.Image.ScaleType scale_type = 2 [default = CENTER_INSIDE, deprecated = true];</code>
     */
    @java.lang.Deprecated boolean hasScaleType();
    /**
     * <pre>
     * How the image should be scaled.
     * DEPRECATED: use the scale_type on Style message instead
     * </pre>
     *
     * <code>optional .search.now.ui.piet.Image.ScaleType scale_type = 2 [default = CENTER_INSIDE, deprecated = true];</code>
     */
    @java.lang.Deprecated com.google.search.now.ui.piet.ImagesProto.Image.ScaleType getScaleType();

    /**
     * <pre>
     * The tint to be applied to this icon. If this optional field is not
     * provided, then no tint will be applied. See [INTERNAL LINK]
     * </pre>
     *
     * <code>optional fixed32 tint_color = 3;</code>
     */
    boolean hasTintColor();
    /**
     * <pre>
     * The tint to be applied to this icon. If this optional field is not
     * provided, then no tint will be applied. See [INTERNAL LINK]
     * </pre>
     *
     * <code>optional fixed32 tint_color = 3;</code>
     */
    int getTintColor();
  }
  /**
   * <pre>
   * An image asset.
   * </pre>
   *
   * Protobuf type {@code search.now.ui.piet.Image}
   */
  public  static final class Image extends
      com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
        Image, Image.Builder> implements
      // @@protoc_insertion_point(message_implements:search.now.ui.piet.Image)
      ImageOrBuilder {
    private Image() {
      sources_ = emptyProtobufList();
      scaleType_ = 1;
    }
    /**
     * <pre>
     * The type of scaling to apply.
     * </pre>
     *
     * Protobuf enum {@code search.now.ui.piet.Image.ScaleType}
     */
    public enum ScaleType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * When scale type is unspecified, we err on the side of preserving all
       * areas of the image, so this is equivalent to CENTER_INSIDE.
       * </pre>
       *
       * <code>SCALE_TYPE_UNSPECIFIED = 0;</code>
       */
      SCALE_TYPE_UNSPECIFIED(0),
      /**
       * <pre>
       * Scale the image uniformly such that width or height will be equal to the
       * size of its view. The image will not be cropped.
       * </pre>
       *
       * <code>CENTER_INSIDE = 1;</code>
       */
      CENTER_INSIDE(1),
      /**
       * <pre>
       * Scale the image uniformly to fill its view. Some portion of the image
       * will be cropped.
       * </pre>
       *
       * <code>CENTER_CROP = 2;</code>
       */
      CENTER_CROP(2),
      ;

      /**
       * <pre>
       * When scale type is unspecified, we err on the side of preserving all
       * areas of the image, so this is equivalent to CENTER_INSIDE.
       * </pre>
       *
       * <code>SCALE_TYPE_UNSPECIFIED = 0;</code>
       */
      public static final int SCALE_TYPE_UNSPECIFIED_VALUE = 0;
      /**
       * <pre>
       * Scale the image uniformly such that width or height will be equal to the
       * size of its view. The image will not be cropped.
       * </pre>
       *
       * <code>CENTER_INSIDE = 1;</code>
       */
      public static final int CENTER_INSIDE_VALUE = 1;
      /**
       * <pre>
       * Scale the image uniformly to fill its view. Some portion of the image
       * will be cropped.
       * </pre>
       *
       * <code>CENTER_CROP = 2;</code>
       */
      public static final int CENTER_CROP_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ScaleType valueOf(int value) {
        return forNumber(value);
      }

      public static ScaleType forNumber(int value) {
        switch (value) {
          case 0: return SCALE_TYPE_UNSPECIFIED;
          case 1: return CENTER_INSIDE;
          case 2: return CENTER_CROP;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ScaleType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ScaleType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ScaleType>() {
              public ScaleType findValueByNumber(int number) {
                return ScaleType.forNumber(number);
              }
            };

      private final int value;

      private ScaleType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:search.now.ui.piet.Image.ScaleType)
    }

    private int bitField0_;
    public static final int SOURCES_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<com.google.search.now.ui.piet.ImagesProto.ImageSource> sources_;
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
     */
    public java.util.List<com.google.search.now.ui.piet.ImagesProto.ImageSource> getSourcesList() {
      return sources_;
    }
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
     */
    public java.util.List<? extends com.google.search.now.ui.piet.ImagesProto.ImageSourceOrBuilder> 
        getSourcesOrBuilderList() {
      return sources_;
    }
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
     */
    public int getSourcesCount() {
      return sources_.size();
    }
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
     */
    public com.google.search.now.ui.piet.ImagesProto.ImageSource getSources(int index) {
      return sources_.get(index);
    }
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
     */
    public com.google.search.now.ui.piet.ImagesProto.ImageSourceOrBuilder getSourcesOrBuilder(
        int index) {
      return sources_.get(index);
    }
    private void ensureSourcesIsMutable() {
      if (!sources_.isModifiable()) {
        sources_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(sources_);
       }
    }

    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
     */
    private void setSources(
        int index, com.google.search.now.ui.piet.ImagesProto.ImageSource value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSourcesIsMutable();
      sources_.set(index, value);
    }
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
     */
    private void setSources(
        int index, com.google.search.now.ui.piet.ImagesProto.ImageSource.Builder builderForValue) {
      ensureSourcesIsMutable();
      sources_.set(index, builderForValue.build());
    }
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
     */
    private void addSources(com.google.search.now.ui.piet.ImagesProto.ImageSource value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSourcesIsMutable();
      sources_.add(value);
    }
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
     */
    private void addSources(
        int index, com.google.search.now.ui.piet.ImagesProto.ImageSource value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSourcesIsMutable();
      sources_.add(index, value);
    }
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
     */
    private void addSources(
        com.google.search.now.ui.piet.ImagesProto.ImageSource.Builder builderForValue) {
      ensureSourcesIsMutable();
      sources_.add(builderForValue.build());
    }
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
     */
    private void addSources(
        int index, com.google.search.now.ui.piet.ImagesProto.ImageSource.Builder builderForValue) {
      ensureSourcesIsMutable();
      sources_.add(index, builderForValue.build());
    }
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
     */
    private void addAllSources(
        java.lang.Iterable<? extends com.google.search.now.ui.piet.ImagesProto.ImageSource> values) {
      ensureSourcesIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, sources_);
    }
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
     */
    private void clearSources() {
      sources_ = emptyProtobufList();
    }
    /**
     * <pre>
     * Image sources are `repeated` so that a feature author can specify multiple
     * image sources in the order that they should be attempted to be fetched.
     * Clients can go through the list until they find one they wish to fetch,
     * based either on the type of URL (e.g. `https://` versus `asset://`) or
     * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
     * authors are responsible for ensuring that at least one image source is
     * valid and accessible (https://gstatic.com URLs are recommended as the
     * ultimate fallback).
     * See [INTERNAL LINK] for more details on Image handling.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
     */
    private void removeSources(int index) {
      ensureSourcesIsMutable();
      sources_.remove(index);
    }

    public static final int SCALE_TYPE_FIELD_NUMBER = 2;
    private int scaleType_;
    /**
     * <pre>
     * How the image should be scaled.
     * DEPRECATED: use the scale_type on Style message instead
     * </pre>
     *
     * <code>optional .search.now.ui.piet.Image.ScaleType scale_type = 2 [default = CENTER_INSIDE, deprecated = true];</code>
     */
    @java.lang.Deprecated public boolean hasScaleType() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * How the image should be scaled.
     * DEPRECATED: use the scale_type on Style message instead
     * </pre>
     *
     * <code>optional .search.now.ui.piet.Image.ScaleType scale_type = 2 [default = CENTER_INSIDE, deprecated = true];</code>
     */
    @java.lang.Deprecated public com.google.search.now.ui.piet.ImagesProto.Image.ScaleType getScaleType() {
      com.google.search.now.ui.piet.ImagesProto.Image.ScaleType result = com.google.search.now.ui.piet.ImagesProto.Image.ScaleType.forNumber(scaleType_);
      return result == null ? com.google.search.now.ui.piet.ImagesProto.Image.ScaleType.CENTER_INSIDE : result;
    }
    /**
     * <pre>
     * How the image should be scaled.
     * DEPRECATED: use the scale_type on Style message instead
     * </pre>
     *
     * <code>optional .search.now.ui.piet.Image.ScaleType scale_type = 2 [default = CENTER_INSIDE, deprecated = true];</code>
     */
    private void setScaleType(com.google.search.now.ui.piet.ImagesProto.Image.ScaleType value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000001;
      scaleType_ = value.getNumber();
    }
    /**
     * <pre>
     * How the image should be scaled.
     * DEPRECATED: use the scale_type on Style message instead
     * </pre>
     *
     * <code>optional .search.now.ui.piet.Image.ScaleType scale_type = 2 [default = CENTER_INSIDE, deprecated = true];</code>
     */
    private void clearScaleType() {
      bitField0_ = (bitField0_ & ~0x00000001);
      scaleType_ = 1;
    }

    public static final int TINT_COLOR_FIELD_NUMBER = 3;
    private int tintColor_;
    /**
     * <pre>
     * The tint to be applied to this icon. If this optional field is not
     * provided, then no tint will be applied. See [INTERNAL LINK]
     * </pre>
     *
     * <code>optional fixed32 tint_color = 3;</code>
     */
    public boolean hasTintColor() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * The tint to be applied to this icon. If this optional field is not
     * provided, then no tint will be applied. See [INTERNAL LINK]
     * </pre>
     *
     * <code>optional fixed32 tint_color = 3;</code>
     */
    public int getTintColor() {
      return tintColor_;
    }
    /**
     * <pre>
     * The tint to be applied to this icon. If this optional field is not
     * provided, then no tint will be applied. See [INTERNAL LINK]
     * </pre>
     *
     * <code>optional fixed32 tint_color = 3;</code>
     */
    private void setTintColor(int value) {
      bitField0_ |= 0x00000002;
      tintColor_ = value;
    }
    /**
     * <pre>
     * The tint to be applied to this icon. If this optional field is not
     * provided, then no tint will be applied. See [INTERNAL LINK]
     * </pre>
     *
     * <code>optional fixed32 tint_color = 3;</code>
     */
    private void clearTintColor() {
      bitField0_ = (bitField0_ & ~0x00000002);
      tintColor_ = 0;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessageLite
        .ExtendableMessage<com.google.search.now.ui.piet.ImagesProto.Image, com.google.search.now.ui.piet.ImagesProto.Image.Builder>
          .ExtensionWriter extensionWriter =
            newExtensionWriter();
      for (int i = 0; i < sources_.size(); i++) {
        output.writeMessage(1, sources_.get(i));
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeEnum(2, scaleType_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeFixed32(3, tintColor_);
      }
      extensionWriter.writeUntil(536870912, output);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < sources_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, sources_.get(i));
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(2, scaleType_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed32Size(3, tintColor_);
      }
      size += extensionsSerializedSize();
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static com.google.search.now.ui.piet.ImagesProto.Image parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.search.now.ui.piet.ImagesProto.Image parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.search.now.ui.piet.ImagesProto.Image parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.search.now.ui.piet.ImagesProto.Image parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.search.now.ui.piet.ImagesProto.Image parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.search.now.ui.piet.ImagesProto.Image parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.search.now.ui.piet.ImagesProto.Image parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.search.now.ui.piet.ImagesProto.Image parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.search.now.ui.piet.ImagesProto.Image parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.search.now.ui.piet.ImagesProto.Image parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.search.now.ui.piet.ImagesProto.Image prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * An image asset.
     * </pre>
     *
     * Protobuf type {@code search.now.ui.piet.Image}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
          com.google.search.now.ui.piet.ImagesProto.Image, Builder> implements
        // @@protoc_insertion_point(builder_implements:search.now.ui.piet.Image)
        com.google.search.now.ui.piet.ImagesProto.ImageOrBuilder {
      // Construct using com.google.search.now.ui.piet.ImagesProto.Image.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
       */
      public java.util.List<com.google.search.now.ui.piet.ImagesProto.ImageSource> getSourcesList() {
        return java.util.Collections.unmodifiableList(
            instance.getSourcesList());
      }
      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
       */
      public int getSourcesCount() {
        return instance.getSourcesCount();
      }/**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
       */
      public com.google.search.now.ui.piet.ImagesProto.ImageSource getSources(int index) {
        return instance.getSources(index);
      }
      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
       */
      public Builder setSources(
          int index, com.google.search.now.ui.piet.ImagesProto.ImageSource value) {
        copyOnWrite();
        instance.setSources(index, value);
        return this;
      }
      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
       */
      public Builder setSources(
          int index, com.google.search.now.ui.piet.ImagesProto.ImageSource.Builder builderForValue) {
        copyOnWrite();
        instance.setSources(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
       */
      public Builder addSources(com.google.search.now.ui.piet.ImagesProto.ImageSource value) {
        copyOnWrite();
        instance.addSources(value);
        return this;
      }
      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
       */
      public Builder addSources(
          int index, com.google.search.now.ui.piet.ImagesProto.ImageSource value) {
        copyOnWrite();
        instance.addSources(index, value);
        return this;
      }
      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
       */
      public Builder addSources(
          com.google.search.now.ui.piet.ImagesProto.ImageSource.Builder builderForValue) {
        copyOnWrite();
        instance.addSources(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
       */
      public Builder addSources(
          int index, com.google.search.now.ui.piet.ImagesProto.ImageSource.Builder builderForValue) {
        copyOnWrite();
        instance.addSources(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
       */
      public Builder addAllSources(
          java.lang.Iterable<? extends com.google.search.now.ui.piet.ImagesProto.ImageSource> values) {
        copyOnWrite();
        instance.addAllSources(values);
        return this;
      }
      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
       */
      public Builder clearSources() {
        copyOnWrite();
        instance.clearSources();
        return this;
      }
      /**
       * <pre>
       * Image sources are `repeated` so that a feature author can specify multiple
       * image sources in the order that they should be attempted to be fetched.
       * Clients can go through the list until they find one they wish to fetch,
       * based either on the type of URL (e.g. `https://` versus `asset://`) or
       * based on the size of the raw image (e.g. 1x DPI or 2x DPI). Feature
       * authors are responsible for ensuring that at least one image source is
       * valid and accessible (https://gstatic.com URLs are recommended as the
       * ultimate fallback).
       * See [INTERNAL LINK] for more details on Image handling.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.ImageSource sources = 1;</code>
       */
      public Builder removeSources(int index) {
        copyOnWrite();
        instance.removeSources(index);
        return this;
      }

      /**
       * <pre>
       * How the image should be scaled.
       * DEPRECATED: use the scale_type on Style message instead
       * </pre>
       *
       * <code>optional .search.now.ui.piet.Image.ScaleType scale_type = 2 [default = CENTER_INSIDE, deprecated = true];</code>
       */
      @java.lang.Deprecated public boolean hasScaleType() {
        return instance.hasScaleType();
      }
      /**
       * <pre>
       * How the image should be scaled.
       * DEPRECATED: use the scale_type on Style message instead
       * </pre>
       *
       * <code>optional .search.now.ui.piet.Image.ScaleType scale_type = 2 [default = CENTER_INSIDE, deprecated = true];</code>
       */
      @java.lang.Deprecated public com.google.search.now.ui.piet.ImagesProto.Image.ScaleType getScaleType() {
        return instance.getScaleType();
      }
      /**
       * <pre>
       * How the image should be scaled.
       * DEPRECATED: use the scale_type on Style message instead
       * </pre>
       *
       * <code>optional .search.now.ui.piet.Image.ScaleType scale_type = 2 [default = CENTER_INSIDE, deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder setScaleType(com.google.search.now.ui.piet.ImagesProto.Image.ScaleType value) {
        copyOnWrite();
        instance.setScaleType(value);
        return this;
      }
      /**
       * <pre>
       * How the image should be scaled.
       * DEPRECATED: use the scale_type on Style message instead
       * </pre>
       *
       * <code>optional .search.now.ui.piet.Image.ScaleType scale_type = 2 [default = CENTER_INSIDE, deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder clearScaleType() {
        copyOnWrite();
        instance.clearScaleType();
        return this;
      }

      /**
       * <pre>
       * The tint to be applied to this icon. If this optional field is not
       * provided, then no tint will be applied. See [INTERNAL LINK]
       * </pre>
       *
       * <code>optional fixed32 tint_color = 3;</code>
       */
      public boolean hasTintColor() {
        return instance.hasTintColor();
      }
      /**
       * <pre>
       * The tint to be applied to this icon. If this optional field is not
       * provided, then no tint will be applied. See [INTERNAL LINK]
       * </pre>
       *
       * <code>optional fixed32 tint_color = 3;</code>
       */
      public int getTintColor() {
        return instance.getTintColor();
      }
      /**
       * <pre>
       * The tint to be applied to this icon. If this optional field is not
       * provided, then no tint will be applied. See [INTERNAL LINK]
       * </pre>
       *
       * <code>optional fixed32 tint_color = 3;</code>
       */
      public Builder setTintColor(int value) {
        copyOnWrite();
        instance.setTintColor(value);
        return this;
      }
      /**
       * <pre>
       * The tint to be applied to this icon. If this optional field is not
       * provided, then no tint will be applied. See [INTERNAL LINK]
       * </pre>
       *
       * <code>optional fixed32 tint_color = 3;</code>
       */
      public Builder clearTintColor() {
        copyOnWrite();
        instance.clearTintColor();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:search.now.ui.piet.Image)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.search.now.ui.piet.ImagesProto.Image();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (!extensionsAreInitialized()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          sources_.makeImmutable();
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          com.google.search.now.ui.piet.ImagesProto.Image other = (com.google.search.now.ui.piet.ImagesProto.Image) arg1;
          sources_= visitor.visitList(sources_, other.sources_);
          scaleType_ = visitor.visitInt(hasScaleType(), scaleType_,
              other.hasScaleType(), other.scaleType_);
          tintColor_ = visitor.visitInt(
              hasTintColor(), tintColor_,
              other.hasTintColor(), other.tintColor_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(getDefaultInstanceForType(),
                                         input, extensionRegistry, tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  if (!sources_.isModifiable()) {
                    sources_ =
                        com.google.protobuf.GeneratedMessageLite.mutableCopy(sources_);
                  }
                  sources_.add(
                      input.readMessage(com.google.search.now.ui.piet.ImagesProto.ImageSource.parser(), extensionRegistry));
                  break;
                }
                case 16: {
                  int rawValue = input.readEnum();
                  com.google.search.now.ui.piet.ImagesProto.Image.ScaleType value = com.google.search.now.ui.piet.ImagesProto.Image.ScaleType.forNumber(rawValue);
                  if (value == null) {
                    super.mergeVarintField(2, rawValue);
                  } else {
                    bitField0_ |= 0x00000001;
                    scaleType_ = rawValue;
                  }
                  break;
                }
                case 29: {
                  bitField0_ |= 0x00000002;
                  tintColor_ = input.readFixed32();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (com.google.search.now.ui.piet.ImagesProto.Image.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:search.now.ui.piet.Image)
    private static final com.google.search.now.ui.piet.ImagesProto.Image DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Image();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static com.google.search.now.ui.piet.ImagesProto.Image getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Image> PARSER;

    public static com.google.protobuf.Parser<Image> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ImageSourceOrBuilder extends
      // @@protoc_insertion_point(interface_extends:search.now.ui.piet.ImageSource)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * URLs can be "https://" or "asset://".
     * HTTPS URLs can be fetched by a regular network communication library.
     * Asset URLs can be fetched by implementation-specific asset helpers.
     * Asset URLs must be specified in an implementation-agnostic manner.
     * If missing, ERR_IMAGE_URL_EMPTY is raised.
     * </pre>
     *
     * <code>optional string url = 1;</code>
     */
    boolean hasUrl();
    /**
     * <pre>
     * URLs can be "https://" or "asset://".
     * HTTPS URLs can be fetched by a regular network communication library.
     * Asset URLs can be fetched by implementation-specific asset helpers.
     * Asset URLs must be specified in an implementation-agnostic manner.
     * If missing, ERR_IMAGE_URL_EMPTY is raised.
     * </pre>
     *
     * <code>optional string url = 1;</code>
     */
    java.lang.String getUrl();
    /**
     * <pre>
     * URLs can be "https://" or "asset://".
     * HTTPS URLs can be fetched by a regular network communication library.
     * Asset URLs can be fetched by implementation-specific asset helpers.
     * Asset URLs must be specified in an implementation-agnostic manner.
     * If missing, ERR_IMAGE_URL_EMPTY is raised.
     * </pre>
     *
     * <code>optional string url = 1;</code>
     */
    com.google.protobuf.ByteString
        getUrlBytes();

    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    java.util.List<com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition> 
        getConditionsList();
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition getConditions(int index);
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    int getConditionsCount();

    /**
     * <pre>
     * The intrinsic width of this image, expressed in raw pixels. This may be
     * different from the width of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 width_px = 4;</code>
     */
    boolean hasWidthPx();
    /**
     * <pre>
     * The intrinsic width of this image, expressed in raw pixels. This may be
     * different from the width of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 width_px = 4;</code>
     */
    int getWidthPx();

    /**
     * <pre>
     * The intrinsic height of this image, expressed in raw pixels. This may be
     * different from the height of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 height_px = 5;</code>
     */
    boolean hasHeightPx();
    /**
     * <pre>
     * The intrinsic height of this image, expressed in raw pixels. This may be
     * different from the height of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 height_px = 5;</code>
     */
    int getHeightPx();
  }
  /**
   * <pre>
   * A single physical image, as contained in a single image file or embedded
   * resource. To accommodate devices with varying Device Pixel Ratios, each image
   * in a different DPI bucket can be represented as a separate `ImageSource`.
   * E.g. the same image can be offered as multiple resources as:
   *     ImageSource{
   *       url="ic_icon_24&#64;1x.png",
   *       width=24,
   *       height=24
   *     }
   * and:
   *     ImageSource{
   *       url="ic_icon_24&#64;2x.png",
   *       width=48,
   *       height=48
   *     }
   * This enables clients to choose which image to fetch based on the expected
   * width and height, without actually having to fetch it first.
   * These dimensions also allow clients to pre-size the view for the image before
   * it loads so that the view's size doesn't change once the image is loaded.
   * </pre>
   *
   * Protobuf type {@code search.now.ui.piet.ImageSource}
   */
  public  static final class ImageSource extends
      com.google.protobuf.GeneratedMessageLite<
          ImageSource, ImageSource.Builder> implements
      // @@protoc_insertion_point(message_implements:search.now.ui.piet.ImageSource)
      ImageSourceOrBuilder {
    private ImageSource() {
      url_ = "";
      conditions_ = emptyProtobufList();
    }
    private int bitField0_;
    public static final int URL_FIELD_NUMBER = 1;
    private java.lang.String url_;
    /**
     * <pre>
     * URLs can be "https://" or "asset://".
     * HTTPS URLs can be fetched by a regular network communication library.
     * Asset URLs can be fetched by implementation-specific asset helpers.
     * Asset URLs must be specified in an implementation-agnostic manner.
     * If missing, ERR_IMAGE_URL_EMPTY is raised.
     * </pre>
     *
     * <code>optional string url = 1;</code>
     */
    public boolean hasUrl() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * URLs can be "https://" or "asset://".
     * HTTPS URLs can be fetched by a regular network communication library.
     * Asset URLs can be fetched by implementation-specific asset helpers.
     * Asset URLs must be specified in an implementation-agnostic manner.
     * If missing, ERR_IMAGE_URL_EMPTY is raised.
     * </pre>
     *
     * <code>optional string url = 1;</code>
     */
    public java.lang.String getUrl() {
      return url_;
    }
    /**
     * <pre>
     * URLs can be "https://" or "asset://".
     * HTTPS URLs can be fetched by a regular network communication library.
     * Asset URLs can be fetched by implementation-specific asset helpers.
     * Asset URLs must be specified in an implementation-agnostic manner.
     * If missing, ERR_IMAGE_URL_EMPTY is raised.
     * </pre>
     *
     * <code>optional string url = 1;</code>
     */
    public com.google.protobuf.ByteString
        getUrlBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(url_);
    }
    /**
     * <pre>
     * URLs can be "https://" or "asset://".
     * HTTPS URLs can be fetched by a regular network communication library.
     * Asset URLs can be fetched by implementation-specific asset helpers.
     * Asset URLs must be specified in an implementation-agnostic manner.
     * If missing, ERR_IMAGE_URL_EMPTY is raised.
     * </pre>
     *
     * <code>optional string url = 1;</code>
     */
    private void setUrl(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
      url_ = value;
    }
    /**
     * <pre>
     * URLs can be "https://" or "asset://".
     * HTTPS URLs can be fetched by a regular network communication library.
     * Asset URLs can be fetched by implementation-specific asset helpers.
     * Asset URLs must be specified in an implementation-agnostic manner.
     * If missing, ERR_IMAGE_URL_EMPTY is raised.
     * </pre>
     *
     * <code>optional string url = 1;</code>
     */
    private void clearUrl() {
      bitField0_ = (bitField0_ & ~0x00000001);
      url_ = getDefaultInstance().getUrl();
    }
    /**
     * <pre>
     * URLs can be "https://" or "asset://".
     * HTTPS URLs can be fetched by a regular network communication library.
     * Asset URLs can be fetched by implementation-specific asset helpers.
     * Asset URLs must be specified in an implementation-agnostic manner.
     * If missing, ERR_IMAGE_URL_EMPTY is raised.
     * </pre>
     *
     * <code>optional string url = 1;</code>
     */
    private void setUrlBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
      url_ = value.toStringUtf8();
    }

    public static final int CONDITIONS_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.ProtobufList<com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition> conditions_;
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    public java.util.List<com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition> getConditionsList() {
      return conditions_;
    }
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    public java.util.List<? extends com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryConditionOrBuilder> 
        getConditionsOrBuilderList() {
      return conditions_;
    }
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    public int getConditionsCount() {
      return conditions_.size();
    }
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    public com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition getConditions(int index) {
      return conditions_.get(index);
    }
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    public com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryConditionOrBuilder getConditionsOrBuilder(
        int index) {
      return conditions_.get(index);
    }
    private void ensureConditionsIsMutable() {
      if (!conditions_.isModifiable()) {
        conditions_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(conditions_);
       }
    }

    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    private void setConditions(
        int index, com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureConditionsIsMutable();
      conditions_.set(index, value);
    }
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    private void setConditions(
        int index, com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition.Builder builderForValue) {
      ensureConditionsIsMutable();
      conditions_.set(index, builderForValue.build());
    }
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    private void addConditions(com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureConditionsIsMutable();
      conditions_.add(value);
    }
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    private void addConditions(
        int index, com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureConditionsIsMutable();
      conditions_.add(index, value);
    }
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    private void addConditions(
        com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition.Builder builderForValue) {
      ensureConditionsIsMutable();
      conditions_.add(builderForValue.build());
    }
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    private void addConditions(
        int index, com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition.Builder builderForValue) {
      ensureConditionsIsMutable();
      conditions_.add(index, builderForValue.build());
    }
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    private void addAllConditions(
        java.lang.Iterable<? extends com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition> values) {
      ensureConditionsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, conditions_);
    }
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    private void clearConditions() {
      conditions_ = emptyProtobufList();
    }
    /**
     * <pre>
     * This ImageSource is only eligible to be used if *all* the conditions
     * enumerated below are met. If even one condition is unsatisfied, this
     * ImageSource is skipped, and Piet will pick another image. It is recommended
     * to include at least one ImageSource that is loaded unconditionally.
     * </pre>
     *
     * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
     */
    private void removeConditions(int index) {
      ensureConditionsIsMutable();
      conditions_.remove(index);
    }

    public static final int WIDTH_PX_FIELD_NUMBER = 4;
    private int widthPx_;
    /**
     * <pre>
     * The intrinsic width of this image, expressed in raw pixels. This may be
     * different from the width of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 width_px = 4;</code>
     */
    public boolean hasWidthPx() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * The intrinsic width of this image, expressed in raw pixels. This may be
     * different from the width of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 width_px = 4;</code>
     */
    public int getWidthPx() {
      return widthPx_;
    }
    /**
     * <pre>
     * The intrinsic width of this image, expressed in raw pixels. This may be
     * different from the width of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 width_px = 4;</code>
     */
    private void setWidthPx(int value) {
      bitField0_ |= 0x00000002;
      widthPx_ = value;
    }
    /**
     * <pre>
     * The intrinsic width of this image, expressed in raw pixels. This may be
     * different from the width of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 width_px = 4;</code>
     */
    private void clearWidthPx() {
      bitField0_ = (bitField0_ & ~0x00000002);
      widthPx_ = 0;
    }

    public static final int HEIGHT_PX_FIELD_NUMBER = 5;
    private int heightPx_;
    /**
     * <pre>
     * The intrinsic height of this image, expressed in raw pixels. This may be
     * different from the height of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 height_px = 5;</code>
     */
    public boolean hasHeightPx() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * The intrinsic height of this image, expressed in raw pixels. This may be
     * different from the height of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 height_px = 5;</code>
     */
    public int getHeightPx() {
      return heightPx_;
    }
    /**
     * <pre>
     * The intrinsic height of this image, expressed in raw pixels. This may be
     * different from the height of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 height_px = 5;</code>
     */
    private void setHeightPx(int value) {
      bitField0_ |= 0x00000004;
      heightPx_ = value;
    }
    /**
     * <pre>
     * The intrinsic height of this image, expressed in raw pixels. This may be
     * different from the height of the container in which this image should be
     * displayed. This can be used for pre-allocating space for the image before
     * it loads. It is expected that the server will usually provide this field.
     * </pre>
     *
     * <code>optional int32 height_px = 5;</code>
     */
    private void clearHeightPx() {
      bitField0_ = (bitField0_ & ~0x00000004);
      heightPx_ = 0;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeString(1, getUrl());
      }
      for (int i = 0; i < conditions_.size(); i++) {
        output.writeMessage(2, conditions_.get(i));
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt32(4, widthPx_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeInt32(5, heightPx_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(1, getUrl());
      }
      for (int i = 0; i < conditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, conditions_.get(i));
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(4, widthPx_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(5, heightPx_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static com.google.search.now.ui.piet.ImagesProto.ImageSource parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.search.now.ui.piet.ImagesProto.ImageSource parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.search.now.ui.piet.ImagesProto.ImageSource parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.search.now.ui.piet.ImagesProto.ImageSource parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.search.now.ui.piet.ImagesProto.ImageSource parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.search.now.ui.piet.ImagesProto.ImageSource parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.search.now.ui.piet.ImagesProto.ImageSource parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.search.now.ui.piet.ImagesProto.ImageSource parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.search.now.ui.piet.ImagesProto.ImageSource parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.search.now.ui.piet.ImagesProto.ImageSource parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.search.now.ui.piet.ImagesProto.ImageSource prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * A single physical image, as contained in a single image file or embedded
     * resource. To accommodate devices with varying Device Pixel Ratios, each image
     * in a different DPI bucket can be represented as a separate `ImageSource`.
     * E.g. the same image can be offered as multiple resources as:
     *     ImageSource{
     *       url="ic_icon_24&#64;1x.png",
     *       width=24,
     *       height=24
     *     }
     * and:
     *     ImageSource{
     *       url="ic_icon_24&#64;2x.png",
     *       width=48,
     *       height=48
     *     }
     * This enables clients to choose which image to fetch based on the expected
     * width and height, without actually having to fetch it first.
     * These dimensions also allow clients to pre-size the view for the image before
     * it loads so that the view's size doesn't change once the image is loaded.
     * </pre>
     *
     * Protobuf type {@code search.now.ui.piet.ImageSource}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.google.search.now.ui.piet.ImagesProto.ImageSource, Builder> implements
        // @@protoc_insertion_point(builder_implements:search.now.ui.piet.ImageSource)
        com.google.search.now.ui.piet.ImagesProto.ImageSourceOrBuilder {
      // Construct using com.google.search.now.ui.piet.ImagesProto.ImageSource.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * URLs can be "https://" or "asset://".
       * HTTPS URLs can be fetched by a regular network communication library.
       * Asset URLs can be fetched by implementation-specific asset helpers.
       * Asset URLs must be specified in an implementation-agnostic manner.
       * If missing, ERR_IMAGE_URL_EMPTY is raised.
       * </pre>
       *
       * <code>optional string url = 1;</code>
       */
      public boolean hasUrl() {
        return instance.hasUrl();
      }
      /**
       * <pre>
       * URLs can be "https://" or "asset://".
       * HTTPS URLs can be fetched by a regular network communication library.
       * Asset URLs can be fetched by implementation-specific asset helpers.
       * Asset URLs must be specified in an implementation-agnostic manner.
       * If missing, ERR_IMAGE_URL_EMPTY is raised.
       * </pre>
       *
       * <code>optional string url = 1;</code>
       */
      public java.lang.String getUrl() {
        return instance.getUrl();
      }
      /**
       * <pre>
       * URLs can be "https://" or "asset://".
       * HTTPS URLs can be fetched by a regular network communication library.
       * Asset URLs can be fetched by implementation-specific asset helpers.
       * Asset URLs must be specified in an implementation-agnostic manner.
       * If missing, ERR_IMAGE_URL_EMPTY is raised.
       * </pre>
       *
       * <code>optional string url = 1;</code>
       */
      public com.google.protobuf.ByteString
          getUrlBytes() {
        return instance.getUrlBytes();
      }
      /**
       * <pre>
       * URLs can be "https://" or "asset://".
       * HTTPS URLs can be fetched by a regular network communication library.
       * Asset URLs can be fetched by implementation-specific asset helpers.
       * Asset URLs must be specified in an implementation-agnostic manner.
       * If missing, ERR_IMAGE_URL_EMPTY is raised.
       * </pre>
       *
       * <code>optional string url = 1;</code>
       */
      public Builder setUrl(
          java.lang.String value) {
        copyOnWrite();
        instance.setUrl(value);
        return this;
      }
      /**
       * <pre>
       * URLs can be "https://" or "asset://".
       * HTTPS URLs can be fetched by a regular network communication library.
       * Asset URLs can be fetched by implementation-specific asset helpers.
       * Asset URLs must be specified in an implementation-agnostic manner.
       * If missing, ERR_IMAGE_URL_EMPTY is raised.
       * </pre>
       *
       * <code>optional string url = 1;</code>
       */
      public Builder clearUrl() {
        copyOnWrite();
        instance.clearUrl();
        return this;
      }
      /**
       * <pre>
       * URLs can be "https://" or "asset://".
       * HTTPS URLs can be fetched by a regular network communication library.
       * Asset URLs can be fetched by implementation-specific asset helpers.
       * Asset URLs must be specified in an implementation-agnostic manner.
       * If missing, ERR_IMAGE_URL_EMPTY is raised.
       * </pre>
       *
       * <code>optional string url = 1;</code>
       */
      public Builder setUrlBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setUrlBytes(value);
        return this;
      }

      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      public java.util.List<com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition> getConditionsList() {
        return java.util.Collections.unmodifiableList(
            instance.getConditionsList());
      }
      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      public int getConditionsCount() {
        return instance.getConditionsCount();
      }/**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      public com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition getConditions(int index) {
        return instance.getConditions(index);
      }
      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      public Builder setConditions(
          int index, com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition value) {
        copyOnWrite();
        instance.setConditions(index, value);
        return this;
      }
      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      public Builder setConditions(
          int index, com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition.Builder builderForValue) {
        copyOnWrite();
        instance.setConditions(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      public Builder addConditions(com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition value) {
        copyOnWrite();
        instance.addConditions(value);
        return this;
      }
      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      public Builder addConditions(
          int index, com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition value) {
        copyOnWrite();
        instance.addConditions(index, value);
        return this;
      }
      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      public Builder addConditions(
          com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition.Builder builderForValue) {
        copyOnWrite();
        instance.addConditions(builderForValue);
        return this;
      }
      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      public Builder addConditions(
          int index, com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition.Builder builderForValue) {
        copyOnWrite();
        instance.addConditions(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      public Builder addAllConditions(
          java.lang.Iterable<? extends com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition> values) {
        copyOnWrite();
        instance.addAllConditions(values);
        return this;
      }
      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      public Builder clearConditions() {
        copyOnWrite();
        instance.clearConditions();
        return this;
      }
      /**
       * <pre>
       * This ImageSource is only eligible to be used if *all* the conditions
       * enumerated below are met. If even one condition is unsatisfied, this
       * ImageSource is skipped, and Piet will pick another image. It is recommended
       * to include at least one ImageSource that is loaded unconditionally.
       * </pre>
       *
       * <code>repeated .search.now.ui.piet.MediaQueryCondition conditions = 2;</code>
       */
      public Builder removeConditions(int index) {
        copyOnWrite();
        instance.removeConditions(index);
        return this;
      }

      /**
       * <pre>
       * The intrinsic width of this image, expressed in raw pixels. This may be
       * different from the width of the container in which this image should be
       * displayed. This can be used for pre-allocating space for the image before
       * it loads. It is expected that the server will usually provide this field.
       * </pre>
       *
       * <code>optional int32 width_px = 4;</code>
       */
      public boolean hasWidthPx() {
        return instance.hasWidthPx();
      }
      /**
       * <pre>
       * The intrinsic width of this image, expressed in raw pixels. This may be
       * different from the width of the container in which this image should be
       * displayed. This can be used for pre-allocating space for the image before
       * it loads. It is expected that the server will usually provide this field.
       * </pre>
       *
       * <code>optional int32 width_px = 4;</code>
       */
      public int getWidthPx() {
        return instance.getWidthPx();
      }
      /**
       * <pre>
       * The intrinsic width of this image, expressed in raw pixels. This may be
       * different from the width of the container in which this image should be
       * displayed. This can be used for pre-allocating space for the image before
       * it loads. It is expected that the server will usually provide this field.
       * </pre>
       *
       * <code>optional int32 width_px = 4;</code>
       */
      public Builder setWidthPx(int value) {
        copyOnWrite();
        instance.setWidthPx(value);
        return this;
      }
      /**
       * <pre>
       * The intrinsic width of this image, expressed in raw pixels. This may be
       * different from the width of the container in which this image should be
       * displayed. This can be used for pre-allocating space for the image before
       * it loads. It is expected that the server will usually provide this field.
       * </pre>
       *
       * <code>optional int32 width_px = 4;</code>
       */
      public Builder clearWidthPx() {
        copyOnWrite();
        instance.clearWidthPx();
        return this;
      }

      /**
       * <pre>
       * The intrinsic height of this image, expressed in raw pixels. This may be
       * different from the height of the container in which this image should be
       * displayed. This can be used for pre-allocating space for the image before
       * it loads. It is expected that the server will usually provide this field.
       * </pre>
       *
       * <code>optional int32 height_px = 5;</code>
       */
      public boolean hasHeightPx() {
        return instance.hasHeightPx();
      }
      /**
       * <pre>
       * The intrinsic height of this image, expressed in raw pixels. This may be
       * different from the height of the container in which this image should be
       * displayed. This can be used for pre-allocating space for the image before
       * it loads. It is expected that the server will usually provide this field.
       * </pre>
       *
       * <code>optional int32 height_px = 5;</code>
       */
      public int getHeightPx() {
        return instance.getHeightPx();
      }
      /**
       * <pre>
       * The intrinsic height of this image, expressed in raw pixels. This may be
       * different from the height of the container in which this image should be
       * displayed. This can be used for pre-allocating space for the image before
       * it loads. It is expected that the server will usually provide this field.
       * </pre>
       *
       * <code>optional int32 height_px = 5;</code>
       */
      public Builder setHeightPx(int value) {
        copyOnWrite();
        instance.setHeightPx(value);
        return this;
      }
      /**
       * <pre>
       * The intrinsic height of this image, expressed in raw pixels. This may be
       * different from the height of the container in which this image should be
       * displayed. This can be used for pre-allocating space for the image before
       * it loads. It is expected that the server will usually provide this field.
       * </pre>
       *
       * <code>optional int32 height_px = 5;</code>
       */
      public Builder clearHeightPx() {
        copyOnWrite();
        instance.clearHeightPx();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:search.now.ui.piet.ImageSource)
    }
    protected final Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.search.now.ui.piet.ImagesProto.ImageSource();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          conditions_.makeImmutable();
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          com.google.search.now.ui.piet.ImagesProto.ImageSource other = (com.google.search.now.ui.piet.ImagesProto.ImageSource) arg1;
          url_ = visitor.visitString(
              hasUrl(), url_,
              other.hasUrl(), other.url_);
          conditions_= visitor.visitList(conditions_, other.conditions_);
          widthPx_ = visitor.visitInt(
              hasWidthPx(), widthPx_,
              other.hasWidthPx(), other.widthPx_);
          heightPx_ = visitor.visitInt(
              hasHeightPx(), heightPx_,
              other.hasHeightPx(), other.heightPx_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(tag, input)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  String s = input.readString();
                  bitField0_ |= 0x00000001;
                  url_ = s;
                  break;
                }
                case 18: {
                  if (!conditions_.isModifiable()) {
                    conditions_ =
                        com.google.protobuf.GeneratedMessageLite.mutableCopy(conditions_);
                  }
                  conditions_.add(
                      input.readMessage(com.google.search.now.ui.piet.MediaQueriesProto.MediaQueryCondition.parser(), extensionRegistry));
                  break;
                }
                case 32: {
                  bitField0_ |= 0x00000002;
                  widthPx_ = input.readInt32();
                  break;
                }
                case 40: {
                  bitField0_ |= 0x00000004;
                  heightPx_ = input.readInt32();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (com.google.search.now.ui.piet.ImagesProto.ImageSource.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:search.now.ui.piet.ImageSource)
    private static final com.google.search.now.ui.piet.ImagesProto.ImageSource DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ImageSource();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static com.google.search.now.ui.piet.ImagesProto.ImageSource getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ImageSource> PARSER;

    public static com.google.protobuf.Parser<ImageSource> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
